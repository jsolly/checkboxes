---
import stats from "../../data/framework-stats.json";
import type { FrameworkStats, FrameworkStatsRecord } from "../../types/stats";
import PerformanceBadge from "../shared/PerformanceBadge.astro";

// Define valid frameworks type based on the stats object
type ValidFrameworks = keyof typeof stats;

interface Props {
	framework: ValidFrameworks;
	title: string;
}

const { framework, title } = Astro.props;

// The type assertion is now safe because Props ensures framework is valid
const frameworkStats = (stats as FrameworkStatsRecord)[
	framework
] as FrameworkStats;

// Optional: Add runtime validation if you want to be extra safe
if (!frameworkStats) {
	throw new Error(
		`Invalid framework: ${framework}. Valid frameworks are: ${Object.keys(stats).join(", ")}`,
	);
}
---

<div 
	class="framework-container backdrop-blur-sm bg-white/90 rounded-xl shadow-lg border border-slate-200" 
	data-framework={framework}
>
	<PerformanceBadge stats={frameworkStats} />
	<div class="opacity-0 transition-opacity duration-300" data-framework-wrapper>
		<div class="bg-white/40 rounded-xl border border-white/50 shadow-lg overflow-hidden relative">
			<div 
				class="bg-white/60 px-4 py-3 flex border-b border-white/20 items-center justify-between backdrop-blur-md"
			>
				<h3 class="font-semibold text-gray-700 select-none">
					{title}
				</h3>
			</div>
			<div class="framework-content">
				<slot />
			</div>
		</div>
	</div>
</div>

<script is:inline define:vars={{ framework }}>
	// Only initialize when the component becomes visible
	const wrappers = document.querySelectorAll(`[data-framework="${framework}"] [data-framework-wrapper]`);
	wrappers.forEach(wrapper => {
		const observer = new IntersectionObserver((entries) => {
			entries.forEach(entry => {
				if (entry.isIntersecting) {
					wrapper.classList.remove('opacity-0');
					wrapper.classList.add('opacity-100');
					observer.unobserve(wrapper);
				}
			});
		}, {
			threshold: 0.1,
			rootMargin: '50px'
		});
		
		observer.observe(wrapper);
	});
</script>